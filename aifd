#!/usr/bin/env bash

#
# Anti Import from Derivation
#

set -eo pipefail

_usage() {
#:p[echo 'echo >&2 "$*';cat ./usage.txt; echo '"']:
echo >&2 "$*
Usage: $(basename "$0") [OPTIONS] [FILES]

Options:
    -h        Show this message
    -e INDEX  Run specific entry
    -f        Fail fast, halt on entry failure
    -l        Print input file paths
    -m        Print manifest file path
    -u        Print only files from succesfull entries (use with -l and -m)
    -q        Quiet
    -n        Dry run
    -d        Debug output

Entry properties:
    cmd             Bash shell commands to execute
    required_files  Files that are required to run entry
    files           Files that are checked for changes
    success         Don't abort on entry faliure
    ignore          Skip entry

Exit codes:
    1         Error or failure
    2         Input files has changes
    8         This message
"

#:#
  exit 8
}

_err() { [[ -z $* || -n $_quiet ]] || echo >&2 "$_pref[ERROR] $*"; }
_info() { [[ -z $* || -n $_quiet ]] || echo >&2 "$_pref$*"; }
__pref() {
  if [[ -n $_quiet ]]; then
    cat 2>&1 >/dev/null;
  else
    stdbuf -oL -eL sed "s|^|$_pref|"
  fi
}

_sha() {
  cat "$@" 2>/dev/null | sha256sum | cut -d " " -f1
}

_run_entry() {
  local ignore
  local sha
  local new_sha
  local cmd
  local files_rel
  local success
  local ext=0
  local pref=$_pref

  if [[ -z $dry ]]; then
    _no_print=$_updated
  else
    _no_print=
  fi

  _read_entry

  ignore=$(dasel select -r json --plain --null ".ignore" <<<"$_entry_json")
  if [[ $ignore == "true" || $ignore == "1" ]]; then
    _info "Ignoring due to property 'ignore=$ignore'"
    return
  fi

  success=$(dasel select -r json --plain --null ".success" <<<"$_entry_json")
  if _read_required_files; then :
  else
    if [[ $success == "true" || $success == "1" ]]; then
      _info "Continuing due to property 'success=$success'"
      return
    else
      return 1
    fi
  fi

  _read_files

  cmd=$(dasel select -r json --plain --null ".cmd" <<<"$_entry_json")

  if [[ $cmd == "null" ]]; then
    _err "No command specified"
    return 1
  fi

  files_rel=($(realpath --relative-to="$_manifest_dir" "${_files[@]}"))
  _pref="$pref< ${files_rel[@]}: "

  sha=$(dasel select -r json --plain --null ".sha" <<<"$_entry_json")
  new_sha=$(_sha "${_files[@]}" <(echo "$cmd"))
  if [[ $sha != $new_sha ]]; then
    if [[ -n $_dry ]]; then
      _info "Has changes, doing nothing due to dry run (-n)"
      return 2
    fi

    (bash -c \
      'index=$0; files=("$@"); set -xeo pipefail; '"$cmd" \
      $_index "${_files[@]}"
    ) 2>&1 | _pref="$pref> " __pref >&2 || ext=$?

    if [[ $ext == 0 ]]; then
      # Re-calculate input file hash again after run if they have changed
      # during command execution.
      new_sha=$(_sha "${_files[@]}" <(echo "$cmd")) || true
      if dasel put string -f "$_manifest" ".[$_index].sha" "$new_sha"; then :
      else
        _err "Failed to update manifest file '$_manifest'"
        return 1
      fi
    else
      _info "Command FAILED (exit $ext)"
      if [[ $success == "true" || $success == "1" ]]; then
        _info "Continuing due to property 'success=$success'"
        return
      else
        return 1
      fi
    fi
    _no_print=
  else 
    _info "No changes"
  fi
}

_read_required_files() {
  _required_files=($(
    dasel select -r json --plain -m ".required_files.[*]" <<<"$_entry_json" 2>/dev/null \
      || dasel select -r json --plain ".required_files" <<<"$_entry_json" 2>/dev/null \
      || true
  ))
  for f in "${_required_files[@]}"; do
    if [[ ! -r $f ]]; then
      _info "Entry FAILED, required file $f doesn't exist or isn't readable"
      return 1
    fi
  done
}

_read_files() {
  _files=($(
    ( IFS=$'\n'
      echo "${_required_files[*]}"
      (dasel select -r json --plain -m ".files.[*]" <<<"$_entry_json" 2>/dev/null \
        || dasel select -r json --plain ".files" <<<"$_entry_json" 2>/dev/null) \
        || true
    ) | xargs -r sh -c 'realpath $*' _ 2>/dev/null | sort -u
  ))

  if [[ -z $_files ]]; then
    _err "Couldn't read input files"
    return 1
  fi
}

_read_entry() {
  _entry_json=$(dasel select -w json -f "$_manifest" ".[$_index]" 2>/dev/null)
  if [[ $? != 0 ]]; then
    _err "Couldn't get entry #$_index"
    return 1
  fi
}

_read_entries() {
  if [[ -n $_only_entries ]]; then
    _entries=("${_only_entries[@]}")
  else
    _entries=($(dasel select -m --plain -f "$_manifest" '.-'))
  fi
}

_run_manifest() {
  local has_err
  local ext=0

  if [[ ! -f $_manifest ]]; then
    _err "Can't read manifest file '$_manifest'"
    return 1
  fi

  _manifest_dir=$(dirname "$_manifest")
  _manifest_rel=$(realpath --relative-to="$_pwd" "$_manifest")

  _read_entries

  _pref="$_manifest_rel"
  (cd "$_manifest_dir"
    for index in "${_entries[@]}"; do
      ext=0
      _index=$index
      _pref="$_pref#$_index " _run_entry || ext=$?
      if [[ $ext != 0 ]]; then
        has_err=$ext

        if [[ -n $_fail_fast ]]; then
          _info " Aborting due to fail fast option (-f)"
          return $ext
        fi
      fi
      if [[ -z $_no_print && -n $_print_manifest ]]; then
        echo "$_manifest"
      fi

      if [[ -z $_no_print && -n $_print_files ]]; then
        realpath "${_files[@]}"
      fi
    done
    if [[ -n $has_err ]]; then
      return $has_err
    fi
  )
}

_main() {
  local ext=0
  local has_err

  if [[ -z $_args ]]; then
    _err "No manifest files given"
    return 1
  fi

  if _manifests=$(realpath "${_args[@]}" | sort -ru); then :
  else
    _err "Can't resolve manifest files ${_args[*]}"
  fi

  if [[ -n $_only_entries && $(wc -l <<<"$_manifests") != 1 ]]; then
    _err "Can't specify entries to run with multiple manifest files"
    return 1
  fi

  while read -r manifest; do
    ext=0
    _manifest=$manifest

    _run_manifest || ext=$?
    if [[ $ext != 0 ]]; then
      if [[ -n $_fail_fast ]]; then
        return $ext
      else
        has_err=$ext
      fi
    fi
  done <<<"$_manifests"

  if [[ -n $has_err ]]; then
    return $has_err
  fi
}

while getopts he:uflmqnd opt; do
  case $opt in
    h|\?) _usage;;
    e) _only_entries+=("$OPTARG");;
    f) _fail_fast=1;;
    l) _print_files=1;;
    m) _print_manifest=1;;
    u) _updated=1;;
    q) _quiet=1;;
    n) _dry=1;;
    d) _debug=1;;
  esac
done
shift $((OPTIND - 1))

if [ -n "$_debug" ]; then set -x; fi

_pre=
_pwd=$PWD
_args=("$@")

if [[ -z $_args ]]; then
  _args=($(find -name '.aifd.*'))
fi

_main
